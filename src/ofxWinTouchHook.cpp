#include "ofxWinTouchHook.h"

// static touch events
ofEvent<ofTouchEventArgs>	ofxWinTouchHook::touchDown;
ofEvent<ofTouchEventArgs>	ofxWinTouchHook::touchUp;
ofEvent<ofTouchEventArgs>	ofxWinTouchHook::touchMoved;

#ifdef TARGET_WIN32
#include <Windows.h>

// variable to store the HANDLE to the hook. Don't declare it anywhere else then globally
// or you will get problems since every function uses this variable.
HHOOK _hook;

// This struct contains the data received by the hook callback. As you see in the callback function
// it contains the thing you will need: vkCode = virtual key code.
KBDLLHOOKSTRUCT kbdStruct;

// This is the callback function. Consider it the event that is raised when, in this case, 
// a key is pressed.
LRESULT __stdcall HookCallback(int nCode, WPARAM wParam, LPARAM lParam)
{
	if (nCode >= 0)
	{
		#ifdef USE_WM_POINTER_EVENTS
		LPMSG pStruct = (LPMSG)lParam;
		UINT message = pStruct->message;
		
		switch (message) {
			case WM_POINTERDOWN:
			case WM_POINTERUPDATE:
			case WM_POINTERUP:
				POINTER_INFO pointerInfo = {};
				// Get frame id from current message
				if (GetPointerInfo(GET_POINTERID_WPARAM(pStruct->wParam), &pointerInfo)) {
					POINT p = pointerInfo.ptPixelLocation;

					// native touch to screen conversion, alt use ofGetWindowPosition offsets
					ScreenToClient(pStruct->hwnd, &p);

					ofTouchEventArgs touchEventArgs;
					touchEventArgs.x = p.x;
					touchEventArgs.y = p.y;
					touchEventArgs.id = pointerInfo.pointerId;

					if (pointerInfo.pointerFlags & POINTER_FLAG_DOWN) {
						ofNotifyEvent(ofxWinTouchHook::touchDown, touchEventArgs);
					}
					else if (pointerInfo.pointerFlags & POINTER_FLAG_UPDATE) {
						ofNotifyEvent(ofxWinTouchHook::touchMoved, touchEventArgs);
					}
					else if (pointerInfo.pointerFlags & POINTER_FLAG_UP) {
						ofNotifyEvent(ofxWinTouchHook::touchUp, touchEventArgs);
					}

					
					//touch.id = pointer->pointerId;
					//if (pointerInfo.pointerFlags & (POINTER_FLAG_CANCELED | POINTER_FLAG_CAPTURECHANGED)) {
					//	/* Cancelled */
					//	//touch.type = ofTouchEventArgs::Type::cancel;
					//	ofNotifyEvent(ofEvents().touchCancelled, touch);
					//	return true;
					//}

				}
				break;
		}

		#else

		// this doesnt fire with WH_CALLWNDPROC, as it's before the message is processed
		// http://cinematography-project-m2-charles.googlecode.com/svn/trunk/Touch2Tuio/TouchHook/TouchHook.cpp
		// WM_TOUCH only
		/*LPMSLLHOOKSTRUCT msg = (LPMSLLHOOKSTRUCT)lParam;
		if (msg->flags & LLMHF_INJECTED) // block injected events (in most cases generated by touches)
		{
			printf("\nBlocked injected (touch) mouse event %d", wParam);
			//sprintf_s(s_buf, "Blocked injected (touch) mouse event\n");
			//WriteConsole(s_out, s_buf, strlen(s_buf), &s_ccount, 0);
			//return CallNextHookEx(0, nCode, wParam, lParam);
			return 0;
		}*/

		// wm_touch/win7
		PCWPSTRUCT pStruct = (PCWPSTRUCT)lParam;
		UINT message = pStruct->message;// ((PCWPSTRUCT)lParam)->message;

		if (message == WM_TOUCH) {

			POINT p;
			UINT numInputs = (UINT)pStruct->wParam; // Number of actual per-contact messages
			TOUCHINPUT* touchInput = new TOUCHINPUT[numInputs]; // Allocate the storage for the parameters of the per-contact messages

			// Unpack message parameters into the array of TOUCHINPUT structures, each
			// representing a message for one single contact.
			HTOUCHINPUT touchLParam = (HTOUCHINPUT)pStruct->lParam;
			if (GetTouchInputInfo(touchLParam, numInputs, touchInput, sizeof(TOUCHINPUT)))
			{
				// For each contact, dispatch the message to the appropriate message
				// handler.
				for (unsigned int i = 0; i<numInputs; ++i)
				{
					// Capture x,y of touch event before iteration through objects
					p.x = TOUCH_COORD_TO_PIXEL(touchInput[i].x);// (touchInput[i].x) / 100;
					p.y = TOUCH_COORD_TO_PIXEL(touchInput[i].y);//(touchInput[i].y) / 100;

					// native touch to screen conversion, alt use ofGetWindowPosition offsets
					ScreenToClient(pStruct->hwnd, &p);

					// OF touch event (only using x,y,and id)
					// only interested in basic down, move, and up events
					ofTouchEventArgs touchEventArgs;
					touchEventArgs.x = p.x;
					touchEventArgs.y = p.y;
					touchEventArgs.id = touchInput[i].dwID;

					if (touchInput[i].dwFlags & TOUCHEVENTF_DOWN)
					{
						//printf("\nDOWN %ld %ld", p.x, p.y);						
						//ofNotifyEvent(ofEvents().touchDown, touchEventArgs);
						ofNotifyEvent(ofxWinTouchHook::touchDown, touchEventArgs);
					}
					else if (touchInput[i].dwFlags & TOUCHEVENTF_MOVE)
					{
						//printf("\nMOVE %ld %ld", p.x, p.y);
						//ofNotifyEvent(ofEvents().touchMoved, touchEventArgs);
						ofNotifyEvent(ofxWinTouchHook::touchMoved, touchEventArgs);
					}
					else if (touchInput[i].dwFlags & TOUCHEVENTF_UP)
					{
						//printf("\nUP %ld %ld", p.x, p.y);
						//ofNotifyEvent(ofEvents().touchUp, touchEventArgs);
						ofNotifyEvent(ofxWinTouchHook::touchUp, touchEventArgs);
					} 

				}
			}
			CloseTouchInputHandle(touchLParam);
			delete[] touchInput;
			
		}
		#endif
		
	}

	// call the next hook in the hook chain. This is nessecary or your hook chain will break and the hook stops
	return CallNextHookEx(_hook, nCode, wParam, lParam);
}
#endif

//--------------------------------------------------------------
void ofxWinTouchHook::EnableTouch() {

	#ifdef TARGET_WIN32

	// for WM_pointer events
	#ifdef USE_WM_POINTER_EVENTS

	// WM_pointer not working
	EnableMouseInPointer(FALSE);
	int windowsHookCode = WH_GETMESSAGE;

	#else

	// for WM_TOUCH - win7+8
	RegisterTouchWindow(ofGetWin32Window(), TWF_WANTPALM);
	int windowsHookCode = WH_CALLWNDPROC;

	#endif

	// Set the hook and set it to use the callback function above
	// WH_KEYBOARD_LL means it will set a low level keyboard hook. More information about it at MSDN.
	// The last 2 parameters are NULL, 0 because the callback function is in the same thread and window as the
	// function that sets and releases the hook. If you create a hack you will not need the callback function 
	// in another place then your own code file anyway. Read more about it at MSDN.
	//if (!(_hook = SetWindowsHookEx(WH_MOUSE_LL, HookCallback, NULL, 0)))
	//hook = SetWindowsHookEx(WH_CALLWNDPROC, LaunchListener, thisModule, threadID);
	// catch before window: http://stackoverflow.com/questions/21069643/is-it-possible-to-remove-touch-messages-wm-pointerdown-etc-that-an-applicatio
	// WM_pointer events will come through on the WH_GETMESSAGE hook - windowsHookCode
	// WM_TOUCH messages will come through on the WH_CALLWNDPROC hook - windowsHookCode
	if (!(_hook = SetWindowsHookEx(windowsHookCode, HookCallback, GetModuleHandle(NULL), GetCurrentThreadId()))) {
		//MessageBox(NULL, "Failed to install hook!", "Error", MB_ICONERROR);
		ofLogError() << "Failed to install hook!";
	}

	#else
	ofLog() << "Not a windows target";
	#endif
}

//--------------------------------------------------------------
void ofxWinTouchHook::DisableTouch() {

	#ifdef TARGET_WIN32
	UnhookWindowsHookEx(_hook);
	#endif
}

//--------------------------------------------------------------
void ofxWinTouchHook::PrintSystemMetrics() {
	
	//https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385(v=vs.85).aspx

	cout << "Nr of monitors " << GetSystemMetrics(SM_CMONITORS) << endl;
	int res = GetSystemMetrics(SM_DIGITIZER);
	cout << "Digitizer " << res << endl;
	
	if ((res & NID_INTEGRATED_TOUCH) > 0) {
		cout << "The device has an integrated touch digitizer." << endl;
	}
	if ((res & NID_EXTERNAL_TOUCH) > 0) {
		cout << "The device has an external touch digitizer." << endl;
	}
	if ((res & NID_INTEGRATED_PEN) > 0) {
		cout << "The device has an external pen digitizer." << endl;
	}
	if ((res & NID_EXTERNAL_PEN) > 0) {
		cout << "The device supports multiple sources of digitizer input." << endl;
	}
	if ((res & NID_MULTI_INPUT) > 0) {
		cout << "The device supports multiple sources of digitizer input." << endl;
	}
	if ((res & NID_READY) > 0) {
		cout << "The device is ready to receive digitizer input." << endl;
	}

	cout << "Nr of touches " << GetSystemMetrics(SM_MAXIMUMTOUCHES) << endl;
}

//--------------------------------------------------------------
bool ofxWinTouchHook::hasTouch() {
	
	if (GetSystemMetrics(SM_DIGITIZER) > 0) {
		return true;
	}
	return false;
}


